【a[0]不使用，用以保留筛选结果a[i]】

插入类排序：-Java size<60
【a[i+1]=a[i]...(i-1~n)，a[i]=a[0]；保存a[i]，后移，填充a[i]】
-直接插入排序-insertionsort-o(n^2)
无序块从前向后遍历，有序快从后向前遍历，直到定位到第一个>=待插入元素的记录左侧

-折半插入排序-bininsertionsort-o(n^2)
折半high/low/mid，直到定位到第一个>=待插入元素的记录，low<=high有效

-希尔排序-shellsort-缩小增量排序-o(n^1.3)
初始化增量序列，常为2^x，最后一次为1。每一次将记录分为若干子序列，将子序列分别进行直接插入排序


交换类排序：
-冒泡排序-bubblesort-o(n^2)
双重循环，外层(1~n-1)控制排序趟数，内层(下标1~n-i)控制排序范围==>设全8，8-7-6-...。小元素上升，大元素下沉。a[j]与a[j+1]之间比较并确定是否交换

-快速排序-quicksort-o(nlogn)-Java基本数据类型&size>60
改进冒泡排序，加以递归，同时降低递归次数，使子序列尽快变短。partition()以while代替递归。
选择一个元素（常为最左端元素）备份作为枢纽。定义low/high，high从右向左找到比枢纽小的就搬到枢纽原来的位置(while)；low从左向右找到比枢纽大的就搬到空出来的位置(while)。最终low=high得到的空位置是枢纽的新位置(while)。此时枢纽左边的元素都比枢纽小但无序，右边的元素都比枢纽大但无序。重复该过程直到序列长度为1


选择类排序：
【交换次数较少】
-简单选择排序-selectionsort-o(n^2)
2层循环，外层1~n-1，内层i~n，每次选择最小的移动到a[i]

-堆排序-heapsort-o(nlogn)-difficult-适合大数据量
使用数组利用完全二叉树性质构建大顶堆。初始从0~n/2由大到小构建堆，之后交换堆顶与堆尾，忽略更新处，重新重复构建大顶堆。堆构建方式：获取当前最大活动边界bigchild，保证左右孩子值小于双亲值


归并类排序：
-二路归并排序-mergesort-o(nlogn)-（优化后）Java对象&&size>60【important】
递归不断缩小边界low/mid+mid+1/high以拆分数组，直到low>=high。最终返回时将2个不确定长度的merge合并即可


其他类排序：
-基数排序-radixsort-o(n*k)
对多位数字由低位到高位分别进行排序并装入桶中。需要了解待排序数字的位数并取各位分别进行装桶。装桶时不比较，依据编号入桶。对多个桶值相同的数字需要用到队列

